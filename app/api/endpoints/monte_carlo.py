"""
Monte Carlo simulation API endpoints

This module defines FastAPI endpoints for Monte Carlo simulations, including
scenario management and comparing simulation results across different scenarios.
"""
from typing import List, Dict, Any, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, Body
from fastapi.responses import JSONResponse
from pydantic import BaseModel

from app.core.security import get_current_user
from app.models.users import User
from app.models.monte_carlo import (
    MonteCarloSimulationRequest,
    MonteCarloSimulationResult,
    ScenarioDefinition,
    ScenarioType,
    SavedSimulation
)
from app.services.monte_carlo_service import MonteCarloSimulationService
from app.services.supabase_service import SupabaseService
from app.worker.monte_carlo_tasks import run_monte_carlo_simulation
from app.core.logging import setup_logger

logger = setup_logger(__name__)
router = APIRouter()


@router.post("/monte-carlo/simulations", response_model=Dict[str, Any])
async def create_simulation(
    request: MonteCarloSimulationRequest,
    current_user: User = Depends(get_current_user),
    run_async: bool = Query(True, description="Run the simulation asynchronously using Celery")
):
    """
    Create and run a new Monte Carlo simulation
    
    If run_async is True, the simulation will be queued for processing by a worker.
    If run_async is False, the simulation will be processed immediately.
    """
    try:
        logger.info(f"Creating Monte Carlo simulation: {request.name}")
        
        service = MonteCarloSimulationService()
        user_id = current_user.id
        
        if run_async:
            # Queue as a Celery task
            task = run_monte_carlo_simulation.delay(
                request.dict(),
                user_id
            )
            
            return {
                "status": "queued",
                "message": "Simulation has been queued for processing",
                "task_id": task.id,
                "simulation_id": None  # Will be generated by the worker
            }
        else:
            # Run synchronously
            result = await service.run_simulation(request, user_id)
            
            # Save the results to Supabase
            saved_result = await service.save_simulation(request, result, user_id)
            
            return {
                "status": "completed",
                "message": "Simulation completed successfully",
                "task_id": None,
                "simulation_id": result.id,
                "result": result
            }
    except Exception as e:
        logger.error(f"Error creating Monte Carlo simulation: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error creating simulation: {str(e)}")


@router.post("/monte-carlo/simulations/with-scenario", response_model=Dict[str, Any])
async def run_simulation_with_scenario(
    request: MonteCarloSimulationRequest,
    scenario_id: str = Query(..., description="ID of the scenario to apply"),
    current_user: User = Depends(get_current_user),
    run_async: bool = Query(True, description="Run the simulation asynchronously using Celery")
):
    """
    Run a Monte Carlo simulation with a specific scenario applied
    
    The scenario will be retrieved, applied to the simulation request, and then
    the simulation will be run with the modified parameters.
    """
    try:
        logger.info(f"Creating Monte Carlo simulation with scenario {scenario_id}")
        
        service = MonteCarloSimulationService()
        user_id = current_user.id
        
        if run_async:
            # Queue as a Celery task with scenario
            task = run_monte_carlo_simulation.delay(
                request.dict(),
                user_id,
                scenario_id=scenario_id
            )
            
            return {
                "status": "queued",
                "message": f"Simulation with scenario {scenario_id} has been queued for processing",
                "task_id": task.id,
                "simulation_id": None,
                "scenario_id": scenario_id
            }
        else:
            # Run synchronously with scenario
            result = await service.run_simulation_with_scenario(
                request, 
                scenario_id, 
                user_id
            )
            
            # Save the results to Supabase
            saved_result = await service.save_simulation(request, result, user_id)
            
            return {
                "status": "completed",
                "message": "Simulation completed successfully",
                "task_id": None,
                "simulation_id": result.id,
                "scenario_id": scenario_id,
                "result": result
            }
    except Exception as e:
        logger.error(f"Error creating Monte Carlo simulation with scenario: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error creating simulation with scenario: {str(e)}")


@router.get("/monte-carlo/simulations/{simulation_id}", response_model=SavedSimulation)
async def get_simulation(
    simulation_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Get a saved Monte Carlo simulation by ID
    """
    try:
        service = MonteCarloSimulationService()
        user_id = current_user.id
        
        simulation = await service.get_saved_simulation(simulation_id, user_id)
        
        if not simulation:
            raise HTTPException(status_code=404, detail=f"Simulation not found: {simulation_id}")
            
        return simulation
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving simulation {simulation_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error retrieving simulation: {str(e)}")


@router.get("/monte-carlo/simulations", response_model=List[Dict[str, Any]])
async def list_simulations(
    current_user: User = Depends(get_current_user),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of results to return"),
    offset: int = Query(0, ge=0, description="Number of results to skip")
):
    """
    List all Monte Carlo simulations for the current user
    """
    try:
        user_id = current_user.id
        supabase = SupabaseService()
        
        simulations = await supabase.list_simulations(user_id, limit=limit, offset=offset)
        
        return simulations
    except Exception as e:
        logger.error(f"Error listing simulations: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error listing simulations: {str(e)}")


@router.post("/monte-carlo/scenarios/compare", response_model=Dict[str, Any])
async def compare_scenarios(
    base_request: MonteCarloSimulationRequest,
    scenario_ids: List[str] = Body(..., description="List of scenario IDs to compare"),
    current_user: User = Depends(get_current_user),
    metrics_to_compare: List[str] = Body(None, description="List of metrics to compare"),
    percentiles_to_compare: List[float] = Body(None, description="List of percentiles to compare")
):
    """
    Run Monte Carlo simulations with different scenarios and compare the results
    
    This will run the simulation multiple times with different scenarios applied
    and return a comparison of the results.
    """
    try:
        logger.info(f"Comparing scenarios: {', '.join(scenario_ids)}")
        
        service = MonteCarloSimulationService()
        user_id = current_user.id
        
        comparison_result = await service.compare_scenarios(
            base_request,
            scenario_ids,
            user_id,
            metrics_to_compare,
            percentiles_to_compare
        )
        
        return comparison_result
    except Exception as e:
        logger.error(f"Error comparing scenarios: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error comparing scenarios: {str(e)}")


@router.delete("/monte-carlo/simulations/{simulation_id}", response_model=Dict[str, Any])
async def delete_simulation(
    simulation_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Delete a saved Monte Carlo simulation
    """
    try:
        user_id = current_user.id
        supabase = SupabaseService()
        
        # Verify the simulation belongs to the user
        simulation = await supabase.get_simulation(simulation_id, user_id)
        
        if not simulation:
            raise HTTPException(status_code=404, detail=f"Simulation not found: {simulation_id}")
            
        # Delete the simulation
        await supabase.delete_simulation(simulation_id, user_id)
        
        return {
            "status": "success",
            "message": f"Simulation {simulation_id} deleted successfully",
            "simulation_id": simulation_id
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting simulation {simulation_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error deleting simulation: {str(e)}")
